#ifndef dvbgen_inner_intrlv_hh
#define dvbgen_inner_intrlv_hh
#include "dvbgen_param.hh"
class InnerIntrlv {
public:
  /*!
    P_constel = 2,4,6
    P_Nmax    = 1512, 3024, 6048
    P_Mode    = Mode2K,Mode4K,Mode8K//2048, 4096, 8192
    P_bitintrlv_sz = 126;

    input_sz_byte = P_Nmax*P_constel/8 (378->4536)
    ouput_sz_byte = P_Nmax
   */ 
  int P_constel;
  int P_Nmax;
  int P_Mmax;

  int symMod2; //for symbol interleaver
  Sigui8 Hq;
  Sigui8 O_intrlv; 

  //ibit on ibyte goes to o_bit on o_sym
  uint8  tab_bit[378][8];//bit index //(126*v*4)/8
  uint16 tab_sym[378][8];//sym index //maxsym = 126*4 

#ifdef check_inner_intrlv 
  FILE * DUMP_inner_intrlv;
  FILE * DUMP_inner_intrlv_I0;
  FILE * DUMP_input;
  FILE * DUMP_tab;
#endif

  InnerIntrlv(DvbParam::Mode P_Mode, DvbParam::Constel vP_constel){
    P_Mmax = P_Mode;

    switch(P_Mmax){
    case  2048: P_Nmax = 1512; break;
    case  4096: P_Nmax = 3024; break;
    case  8192: P_Nmax = 6048; break;
    default : MSG_ERROR("unknown Mode!!"); break;
    }

    P_constel = vP_constel;

    int8 iIntrl[6];//for demux
    
    switch(P_constel){
    case  DvbParam::CQPSK  : {int8 viIntrl[] = {0, 1,-1,-1,-1,-1};memcpy(iIntrl,viIntrl,6);} break;
    case  DvbParam::C16QAM : {int8 viIntrl[] = {0, 2, 1, 3,-1,-1};memcpy(iIntrl,viIntrl,6);} break;
    case  DvbParam::C64QAM : {int8 viIntrl[] = {0, 2, 4, 1, 3, 5};memcpy(iIntrl,viIntrl,6);} break;
    default : MSG_ERROR("unknown Constel!!"); break;
    }
    int dIntrl[6] = {0,63,21,84,105,42};//interleaver delay = 126-{0,63,105,42,21,84}

    /**generate lookup table**/


#ifdef check_inner_intrlv
    DUMP_tab  = fopen ("z_dump/tab_bit_intrlv.txt", "w");
#endif

    int useful_sz = 63*P_constel; //(126*4*P_constel)/8;
    int bitcount = 0;
    for(int ibyte=0;ibyte<useful_sz;ibyte++){
      for(int ibit=7;ibit>=0;ibit--){ //MSB first
	uint8  o_bit;
	uint16 o_sym;

	int isym       = bitcount/P_constel;
	int imodv      = bitcount  - P_constel*isym;
	int curIntrl   = iIntrl[imodv]; //current Interleaver
	int ibloc      = isym/126;
	int ilocalsym  = isym-ibloc*126;

	o_sym = 126*ibloc + (ilocalsym + dIntrl[curIntrl])%126;
	o_bit = P_constel-curIntrl; // y = ( a_0,a_1,...,a_(v-1) ) 

	//ibit on ibyte goes to o_bit on o_sym
	tab_bit[ibyte][ibit] = o_bit; 
	tab_sym[ibyte][ibit] = o_sym;

#ifdef check_inner_intrlv
	fprintf (DUMP_tab, "%u %u\n",o_sym,o_bit);
#endif
	bitcount++;
      }
    }
#ifdef check_inner_intrlv
    fclose(DUMP_tab);
#endif

    O_intrlv.zeros(P_Nmax);

    /***Build Hq for Symbol Interleaver****/
    int Nr = log2(P_Mmax);
    Hq.zeros(P_Nmax);
    uint8 perm_table[12];

    switch (P_Mmax){
    case 2048: { uint8 vperm_table[]={4, 3, 9, 6, 2, 8, 1, 5 , 7, 0}       ; memcpy(perm_table,vperm_table,10); } break;
    case 8192: { uint8 vperm_table[]={7, 1, 4, 2, 9, 6, 8, 10, 0, 3, 11, 5}; memcpy(perm_table,vperm_table,12); } break;
    default:  MSG_ERROR("unsupported OFDM Mode!!"); break;
    }

    Sigui8 Rpi; Rpi.SetSize(Nr-1);
    Sigui8 Ri; Ri.SetSize(Nr-1);
    
    int qq = 0;
    for(int ii = 0;ii<P_Mmax;ii++){
      /* compute Ri */
      switch (ii){
      case 0:
        Rpi = 0; break;
      case 1:
        Rpi = 0; break;
      case 2:
        Rpi = 0; Rpi(1) = 1; break;
      default:
        Rpi(0,Nr-3) = Rpi(1,Nr-2); 
	if(P_Mmax==2048){
	  Rpi(Nr-2) = Rpi(0) ^ Rpi(3);
	}
	else if(P_Mmax==8192) {
	    Rpi(Nr-2) = Rpi(0) ^ Rpi(1) ^ Rpi(4) ^ Rpi(6);
	} else myabort();
      }

      for (int kk = 0; kk<Nr-1;kk++){
      Ri(perm_table[kk]) = Rpi(kk);
      }
      /* compute H(q) */
      Hq(qq) = (ii&1) * pow(2,Nr-1);
      for (int jj = 0;jj<Nr-1;jj++){
	Hq(qq) +=  Ri(jj) * pow(2,jj);
      }
      if (Hq(qq) < P_Nmax){
	qq = qq + 1;
      }
    }
    /***Hq is built for Symbol Interleaver****/
    
    symMod2 = 0; /*init symbol count for interleaver*/


#ifdef check_inner_intrlv
    DUMP_inner_intrlv      = fopen ("z_dump/inner_intrlv.bin", "wb");
    DUMP_input             = fopen ("z_dump/inner_intrlv_input.bin", "wb");
    DUMP_inner_intrlv_I0 = fopen ("z_dump/intrlvI0.txt", "w");
#endif

  }
    
  ~InnerIntrlv(){
#ifdef check_inner_intrlv
    fclose(DUMP_inner_intrlv )     ; MSG("Write File: z_dump/inner_intrlv.bin");
    fclose(DUMP_input        )     ; MSG("Write File: z_dump/inner_intrlv_input.bin");
    fclose(DUMP_inner_intrlv_I0);
#endif
  }

  int get_input_sz(){
    return    P_Nmax*P_constel/8;
  }
  int get_output_sz(){
    return   P_Nmax;
  }

  void compute(Sigui8 &O_data, Sigui8 &I_data)
  {
    int outputSz = O_data.size();

#ifdef check_inner_intrlv
    for(int ii=0;ii<I_data.size();ii++){
      fwrite(I_data.bufferA+ii , 1 , 1 , DUMP_input );
    }
#endif

#ifdef BOUNDSCHECKING
    if(O_data.size()!=get_output_sz())MSG_ERROR("output size is not correct");
    if(I_data.size()!=get_input_sz())MSG_ERROR("input size is not correct");
#endif

    /************ Bit interleaver *******************************************************/
   
    int nb_bbloc  = P_Nmax/(126*4);//1 bbloc = 4 blocs
    int bbloc_sz  = 63* P_constel;

    int ibyte = 0;

    uint8* pidata = (uint8*)(I_data.bufferA);
    uint8* podata = (uint8*)(O_intrlv.bufferA);
     
    for(int ibbloc=0;ibbloc<nb_bbloc;ibbloc++){
      for(int ibyte=0;ibyte<bbloc_sz;ibyte++){
	SETBIT(podata[tab_sym[ibyte][0]],tab_bit[ibyte][0],GETBIT(pidata[ibyte],1));
	SETBIT(podata[tab_sym[ibyte][1]],tab_bit[ibyte][1],GETBIT(pidata[ibyte],2));
	SETBIT(podata[tab_sym[ibyte][2]],tab_bit[ibyte][2],GETBIT(pidata[ibyte],3));
	SETBIT(podata[tab_sym[ibyte][3]],tab_bit[ibyte][3],GETBIT(pidata[ibyte],4));
	SETBIT(podata[tab_sym[ibyte][4]],tab_bit[ibyte][4],GETBIT(pidata[ibyte],5));
	SETBIT(podata[tab_sym[ibyte][5]],tab_bit[ibyte][5],GETBIT(pidata[ibyte],6));
	SETBIT(podata[tab_sym[ibyte][6]],tab_bit[ibyte][6],GETBIT(pidata[ibyte],7));
        SETBIT(podata[tab_sym[ibyte][7]],tab_bit[ibyte][7],GETBIT(pidata[ibyte],8));
      }
      pidata += bbloc_sz;
      podata += bbloc_sz;
    }
    /************ End Bit interleaver ***************************************************/

#ifdef check_inner_intrlv
    for(int ii=0;ii<outputSz;ii++){
      fwrite(O_intrlv.bufferA+ii , 1 , 1 , DUMP_inner_intrlv );
      //      int tmp; tmp = (int)(*(O_intrlv.bufferA+ii));//O_intrlv(ii);
      fprintf (DUMP_inner_intrlv_I0, "%u \n",GETBIT(O_intrlv(ii),4));
    }
    //DUMP_inner_intrlv_I0 = fopen ("z_dump/intrlvI0.txt", "w");
    //for(int ii=0;ii<outputSz;ii++){
    //  uint8 tmp; tmp = O_intrlv(ii);
    //  fprintf (DUMP_inner_intrlv_I0, "%u %u %u %u %u\n",tmp,GETBIT(tmp,4),GETBIT(tmp,3),GETBIT(tmp,2),GETBIT(tmp,1)); 
    //}
#endif
    /************ Symbol Interleaver*****************************************************/
    if (symMod2==0){
      for(int ii=0;ii<outputSz;ii++){
	O_data(Hq(ii)) = O_intrlv(ii);
      }
    }
    else {
      for(int ii=0;ii<outputSz;ii++){
	O_data(ii) = O_intrlv(Hq(ii));
      }
    }

    /*update counter*/
    symMod2 = (symMod2+1)&1;

// #ifdef check_inner_intrlv
//     for(int ii=0;ii<outputSz;ii++){
//       fwrite(O_data.bufferA+ii , 1 , 1 , DUMP_inner_intrlv );
//     }
// #endif

  }


};


#endif
